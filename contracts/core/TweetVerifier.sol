// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {ITweetVerifier} from "../interfaces/ITweetVerifier.sol";
import {JSONParserLib} from "solady/src/utils/JSONParserLib.sol";
import {Reclaim} from "@reclaimprotocol/verifier-solidity-sdk/contracts/Reclaim.sol";
import {LibString} from "solady/src/utils/LibString.sol"; // Optional: If constructing URLs

/**
 * @title TweetVerifier
 * @dev Verifies Reclaim proofs related to Twitter/X tweet status, specifically checking for Community Notes.
 */
contract TweetVerifier is ITweetVerifier {
    address public immutable reclaimAddress;
    // Store the expected base URL parts if they are constant
    string public constant EXPECTED_URL_PREFIX =
        "https://cdn.syndication.twimg.com/tweet-result?id=";
    string public constant EXPECTED_URL_SUFFIX = "&token=!"; // Adjust if token changes

    error InvalidUrl(); // Error if proof doesn't match expected tweet URL

    constructor(address _reclaim) {
        require(_reclaim != address(0), "Invalid Reclaim address");
        reclaimAddress = _reclaim;
    }

    /**
     * @notice Verifies a Reclaim proof for a specific tweet ID.
     * @param tweetId The ID of the tweet this proof *should* be for.
     * @param reclaimProof The proof object generated by Reclaim.
     * @return hasNote True if the proof indicates a community note was found, false otherwise.
     */
    function verify(
        string memory tweetId, // Pass the specific tweetId
        Reclaim.Proof memory reclaimProof
    ) public view override returns (bool hasNote) {
        // 1. Verify core proof validity using the Reclaim SDK
        // This reverts internally if the proof signatures, timestamps etc. are invalid.
        Reclaim(reclaimAddress).verifyProof(reclaimProof);

        // 2. Verify the proof is for the CORRECT tweet URL
        JSONParserLib.Item memory parsedParams = JSONParserLib.parse(
            reclaimProof.claimInfo.parameters
        );
        // Use `at` which reverts on failure
        JSONParserLib.Item memory urlPtr = JSONParserLib.at(
            parsedParams,
            '"url"'
        );
        require(
            // Convert string to bytes to get length
            bytes(JSONParserLib.value(urlPtr)).length > 0,
            "URL not found in proof parameters"
        );

        string memory parsedUrl = JSONParserLib.decodeString(
            JSONParserLib.value(urlPtr)
        );

        // Construct the expected URL based on the input tweetId
        // Cast strings to bytes for concatenation
        bytes memory expectedUrlBytes = bytes.concat(
            bytes(EXPECTED_URL_PREFIX),
            bytes(tweetId),
            bytes(EXPECTED_URL_SUFFIX)
        );

        // Compare URLs - MUST match to prevent using proof for wrong tweet
        // Using keccak256 is gas-efficient for string comparison
        if (keccak256(bytes(parsedUrl)) != keccak256(expectedUrlBytes)) {
            revert InvalidUrl();
        }

        // 3. Check the proof's context for extracted Community Note data
        // The zkFetch request in helpers.js extracts "noteId" and "noteText" via regex
        // into the proof context's "extractedParameters" field.
        JSONParserLib.Item memory parsedContext = JSONParserLib.parse(
            reclaimProof.claimInfo.context
        );
        JSONParserLib.Item memory extractedParams;
        // Use `at` which reverts on failure, or check length carefully
        // We actually want to check if it exists without reverting immediately
        // Keep context as string for LibString.contains
        string memory contextString = reclaimProof.claimInfo.context;
        string memory keyString = '"extractedParameters"';
        bool hasExtractedParams = LibString.contains(contextString, keyString);

        if (!hasExtractedParams) {
            // If "extractedParameters" key doesn't exist, no regex match occurred.
            return false; // No note found
        }
        // If the key exists, parse it (this might revert if context is malformed, but expected)
        extractedParams = JSONParserLib.at(
            parsedContext,
            '"extractedParameters"'
        );

        // Check if "noteId" was extracted. Its presence indicates a note was found.
        JSONParserLib.Item memory noteIdPtr;
        // Need to check existence safely again
        // Keep extracted part as string for LibString.contains
        string memory extractedString = JSONParserLib.value(extractedParams);
        string memory noteIdKeyString = '"noteId"';
        bool hasNoteId = LibString.contains(extractedString, noteIdKeyString);

        // hasNote is true IF "noteId" was successfully found (key exists)
        // We don't need to check the length of the value here, just presence of the key.
        hasNote = hasNoteId;

        // Note: Could add similar check for "noteText" for redundancy if desired.

        return hasNote;
    }
}
